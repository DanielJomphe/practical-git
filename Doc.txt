1 Git Primer & Best Practices

1.1 Introduction

1.1.1 Why use a Distributed VCS?

What it really amounts to is *flexibility*.

* *To work together on stuff not yet ready to be committed.*
** Let's say you need help with something that doesn't work:
*** *DVCS* You can share ~~commits~~ with someone ~~before~~ committing/pushing them to the official repository.
*** *VCS* ...Use some ingenious, time-eating way, like zipping some files, sending them by email, and knowing it won't be mergeable with your colleague's files. So I think you'll end up not doing much team work.

* *To gain incredible speedups because most operations are local.*
** Consequently, one could argue that not waiting after operations helps keep one's concentration.

* *To have a more useful history of the project.*
** *DVCS* You can ~~visualize~~ what really happened between different commits/merges. The history is a ~~tree/graph~~ structure.
** *VCS* ...You'll have to read more commits because the history is a ~~list~~ structure.

* *To have lightweight branches ~~and~~ easy merges.*
** *DVCS* Why are merges easier? Because of the better history understanding of DVCSes, they ~~know~~ if some parts of a change have already, or not, been merged unto your current branch.
** *VCS* ...Gets lost easily, and more and more as time passes between the branch and the merge; and then, you get the dirty hand-work of fixing the merge.

* *To have ~~meaningful~~ commits.*
** *DVCS* With a ~~bit~~ of discipline and a ~~lot~~ of flexibility, it's easy to locally organize/reorganize multiple commits before pushing them to the official repository, so that they convey a proper historical perspective.
*** Each part of your work can be done in a different, lightweight branch, so you don't mix and match, for example, new functionality changes with refactoring changes with documentation changes with code reformatting changes. See the point? Each one of these changes would have its own commit, so it'd be easy to see the point of each commit afterwards and only check the diffs relevant to a regression, for example.
*** Even if you didn't work in multiple, lightweight branches, you still can have multiple commits before pushing them to the official repository. And you can reorganize them on-the-fly, interactively, and easily, so they carry as much meaning to the team as you want.
** *VCS* ...With a ~~lot~~ of discipline, and ~~no flexibility~~.




1.1.1 Why use Git?

To us, what makes Git more useful than other DVCSes like Mercurial and Bazaar is the following:

* Git is the most integrated with svn.
* Git is the most flexible.
** Particularly, Git has the most complete support for rewriting local historical commits ~~before~~ pushing them to external repositories.
* Git has the most adoption.

Seeing Git is the leader on these fronts, it's easy to make a choice.

By the way, let's take a look at one Git objection:

* It's ~~no more~~ true that Git has almost no Windows support.
** No DVCS yet has first-class, native Windows support.
** Mercurial has TortoiseHg, which, afaik, is a work in progress.
*** Git's command line is so powerful, flexible and ~~starves~~ to be learned and used. TortoiseGit will be there later, but will I really want to use it but for the most basic operations?
** ~~git-svn~~ isn't yet supported under Windows; both Mercurial and Bazaar don't have an equivalent to git-svn anyways.
*** If one is willing to use cygwin, then ~~git-svn~~ is 100% possible on Windows.





1.1.1 Git pitfalls for SVN people

Git wasn't meant to use the same syntax as cvs/svn. It was meant to have the same syntax as BitLocker.

* ~~add~~ is not the same.
** svn: enables tracking of newly added files.
** git: enables tracking (staging, indexing) of new changes, either newly added files or modified files.
* ~~revert~~ is not the same at all (dangerous!).
** svn: reverts local changes.
** git: used to revert ~~old~~ checkouts, AFAIK. You'll probably more often use:
*** ~~checkout~~
*** And in some rare cases, a flavor of ~~reset~~. Be warned, though, that ~~reset~~ is too much publicized by the blog community. If I remember well, it's in ~~Git from bottom up (links at end of page)~~ that you see how ~~checkout~~ is preferable in most cases as a much less dangerous option and more natural one, too.

1.1.1 Git Worst Practices

Let's try to debunk bad habits here.

* Watch out not to grow the habit of using the ~~-a~~ argument to ~~git commit~~ mechanically.
** Let's say you do an interactive staging of some changes to commit, using the wonderful ~~git add -i~~. Then, you ~~commit -a~~. Instead of committing only what you had interactively selected to be committed, you end up committing everything!

1.1 Initial Setup

1.1.1 Setting up a gitosis server

1.1.1.1 Creating new repositories

Let's create a new repository to hold our project codenamed FreeMonkey 

Open up gitosis.conf:

{code}
1$ vi /home/ic-yul/projects/gitosis-admin/gitosis.conf
{code}

Notice the default configuration:

{code}
[gitosis]

[group gitosis-admin]
writable = gitosis-admin
members = ic-yul@yul115347l02
{code}

To create a new repo, we just authorize writing to it and commit+push. To do so, add this to gitosis.conf:


{code}
[group common-freemonkey]
members = ic-yul@yul115347l02
writable = common/free_monkey
{code}

This defines a new group called "common-freemonkey", which is an arbitrary string. "ic-yul@yul115347l02" is a member of common-freemonkey and will have write access to the "free_monkey" repo.

Save this addition to gitosis.conf, commit and push it: 

{code}
1$ git commit -a -m "Allow ic-yul@yul115347l02 W access to free_monkey"
1$ git push
{code}

Now the user "ic-yul@yul115347l02" has access to write to the repo named "free_monkey", but we still haven't created a repo yet. What we will do is create a new repo locally, and then commit+push it: 

{code}
1$ mkdir -p common/free_monkey
1$ cd common/free_monkey
1$ git init
1$ git remote add origin git@172.22.175.158:common/free_monkey.git

# Now add an empty file. *THIS IS MANDATORY*:

1$ touch README
1$ git add .
1$ git commit -m "Initial import"

# do some work, git add, git commit
1$ git push origin master:refs/heads/master
{code}

1.1.1.1 Adding users

The next natural thing to do is to grant some lucky users with commit access to the FreeMonkey project. This is a simple two step process.

First, gather their public SSH keys, and drop them into keydir/ of your local gitosis-admin repository: 

{code}
1$ cd gitosis-admin
1$ cp ~/alice.pub keydir/
1$ cp ~/bob.pub   keydir/
{code}

Note that the key filename must have a ".pub" extension.

Second, edit gitosis.conf and add them to the "members" list:

gitosis.conf changes:

{code}
[group myteam]
- members = jdoe
+ members = jdoe alice bob
  writable = common/free_monkey
{code}

Finally, commit and push: 

{code}
1$ git add keydir/alice.pub keydir/bob.pub
1$ git commit -m "Granted Alice and Bob commit rights to FreeMonkey"
1$ git push
{code}


1.1.1 Setting up Git on Windows

* [Download mSysGit>http://code.google.com/p/msysgit/] & Install it
** Don't pick the option to add all unix tools to your path (the red one)
** Pick OpenSSH

1.1.1.1 Creating ssh keys

In Windows' Explorer, right click and select ~~Git bash here~~

{code}
ssh-keygen -C "joe.smith@compuware.com" -t rsa
{code}

* Use the default file name ~~id_rsa~~.
* *Make a backup copy of the generated keys*, which can be found in your home, e.g.: ~~C:/Doc&Settings/joe-smith/.ssh/~~.

1.1.1 Configuring Git

This updates your ~~~/.gitconfig~~ file:
{code}
$ git config --global user.name     "Joe Smith"
$ git config --global user.email    joe.smith@compuware.com
$ git config --global core.autocrlf false
$ git config --global color.ui      auto
$ git config --list
{code}

For project-based configuration options, remove the ~~--global~~ argument. This will update your project's ~~<project-path>/.git/.gitconfig~~ file instead, and will be shared with the team. Note that project configuration options win over global configuration options.



1.1 Project repository workflow

#warning("*Read and follow closely these instructions.*")

* ~~Joe Smith~~: ~~Boss~~, I need to work on something!
* ~~Boss~~: ~~Joe~~, you'll work on ~~project~~!

#info("Best practice: *An official repo for a project contains at least one ~~staging~~ branch*.\\ \\This is where changes are tried before being merged into the ~~master~~ branch.\\ \\In this example, it's called *edge*.")

{code}
.                    |                      |           OFFICIAL
                     |                      |
                     |                      |             master
                     |                      |               edge
{code}


1.1.1 Setting up a local repository

* ~~Joe Smith~~: ~~Boss~~, I'm setting up for ~~project~~!

1.1.1.1 Checking out from a repository

#info("Best practice: *Clone/fetch/pull from the official repository*.\\ \\Stick to this even if you forked the official repo into another public repository.")

~~Joe~~ runs one of the following options to checkout the project along with its history:
{code}
1$ git clone  git://<server>/<project-path>/OFFICIAL.git
1$ git clone http://<server>/<project-path>/OFFICIAL.git
1$ git clone (SSH: XXXX to be documented later)
{code}
1- Checks out an initial local copy of the OFFICIAL repo.\\
{code}
JS-LOCAL             |                      |           OFFICIAL
                     |                      |
             master <------------------------------------ master
               edge <------------------------------------   edge
{code}

#info("If ~~Joe~~ already had a public fork of this project, he would have done the same:{code}
1$ git clone git://<server>/<project-path>/OFFICIAL.git
{code}1- Note that the Git URL for the clone references the OFFICIAL repo and *not* JS-FORK.\\{code}
JS-LOCAL            |       JS-FORK       |          OFFICIAL
                    |                     |
            master <---------------------------------- master
                    |             master  |
              edge <----------------------------------   edge
                    |               edge  |{code}")

1.1.1.1 Setting up tracking of a remote branch

#info("Best practice: *Automate syncing of official remote branches towards your local repo*.\\ \\Stick to this even if you forked the official repo into another public repository. This way, your working copy will always be the integration point of what's coming from the official repo, and it won't hinder your fork repo in perpetually benefiting from the official changes to the project, although it might not be clear to you now.")

{code}
2$ cd <project>
3$ git branch --track edge origin/edge
{code}
2- Gets inside the project's working tree to interact with git (and with the project, of course).\\
3- Sets up automatic tracking of the OFFICIAL edge branch, for future easy syncing.\\

Note that we don't need to explicitly track the OFFICIAL master branch; this is automatically, implicitly done when you ~~git clone~~.



1.1.1 Setting up topic branches

#info("Best practice: *Make a ~~topic branch~~ for each future feature pushed to the official repository*.\\ \\Try to give the ~~topic branch~~ a name that properly synthesizes the nature of the change.")

* ~~Joe Smith~~: Hey ~~Boss~~, I'll work on ~~topic1~~ and ~~topic2~~!
* ~~Boss~~: Fine, go ahead!

1.1.1.1 Creating a local topic branch

#info("Best practice: *format-branch-names-this-way* and, if they're shared, prefix their name with a parent directory whose name is the initials of the branch's author: *dj/topic-description*")

{code}
1$ git branch   <topic> edge
2$ git checkout <topic>
{code}
or, as a shortcut:
{code}
1+2$ git branch -b <topic> edge
{code}
1- Creates a local branch for ~~topic~~, based off of edge.\\
2- Selects the local ~~topic~~ branch, to work on it.\\
{code}
JS-LOCAL             |                      |           OFFICIAL
                     |                      |
             master  |                      |             master
               edge  |                      |               edge
                     |                      |
            topic-1  |                      |
            topic-2  |                      |
{code}

1.1.1.1.1 Setting up the branch name in shell prompt

[Try it>http://github.com/guides/put-your-git-branch-name-in-your-shell-prompt] and if it works, change this text to reflect it :)

1.1.1 Setting up a sharing repository

#info("Best practice: *Work on a local repo and frequently push your changes to another repo*.\\ \\In this example, the second repo is called *JS-FORK*. It will serve you as a sharing access point for you towards your team, and as a redundant backup.")

1.1.1.1 Setting up a public fork

~~Joe~~ sends his public rsa key to his sysadmin, and asks him to create a sharing repository for him.

{code}
2$ cd <proj-path>
3$ git clone --bare git://<srv>/<proj-path>/OFFICIAL.git JS-FORK.git
{code}
3- Makes a copy of OFFICIAL, without a working tree.\\
{code}
JS-LOCAL             |        JS-FORK       |           OFFICIAL
                     |                      |
             master  |              master <------------- master
               edge  |                edge <-------------   edge
                     |                      |
            topic-1  |                      |
            topic-2  |                      |
{code}

1.1.1.1 Setting up a remote branch in the fork repo

{code}
4$ git checkout   <topic>
5$ git remote add <topic> JOE@<server>:<proj-path>/JS-FORK.git
6$ git fetch      <topic>
{code}
4- Selects the local ~~topic~~ branch, to track the future changes.\\
5- Sets up a tracking reference of the local ~~topic~~ branch unto JS-FORK, for future easy syncing.\\
6- Syncs up the local ~~topic~~ branch ~~from~~ JS-FORK, as a safety measure. (Probably to see if there's already a shared branch of the same name.)\\
{code}
JS-LOCAL             |        JS-FORK       |           OFFICIAL
                     |                      |
             master  |              master  |             master
               edge  |                edge  |               edge
                     |                      |
            topic-1  |        (js/topic-1)  |
            topic-2  |        (js/topic-2)  |
{code}

1.1.1.1 Syncing a local topic branch to a fork repo

{code}
7$ git push <topic> JOE:refs/heads/<topic>
{code}
7- Syncs up the local ~~topic~~ branch towards JS-FORK, effectively creating it on JS-FORK.\\
{code}
JS-LOCAL             |        JS-FORK       |           OFFICIAL
                     |                      |
             master  |              master  |             master
               edge  |                edge  |               edge
                     |                      |
          topic-1 ------------> js/topic-1  |
          topic-2 ------------> js/topic-2  |
{code}

1.1.1.1 Making future branch syncs automatic

{code}
8$ git config branch.<topic>.remote            <joe>
9$ git config branch.<topic>.merge  refs/heads/<joe>
{code}
8-  Makes future 'git push' commands automatically sync the topic branch to JS-FORK.\\
9- Makes future 'git pull' commands automatically sync the topic branch from JS-FORK to JS-LOCAL.\\









1.1.1 Working on topic branches

* ~~Joe~~: Let's work on ~~topic1~~!

1.1.1.1 Making changes on a local topic branch

{code}
1$ git checkout <topic>
{code}
1- Selects the local branch ~~topic~~, to track the related changes.\\
#info("Git's lightweight operation of checking out branches is something that needs to be well understood.\\ \\If you check out a branch, your working directory will need to look 100% like that branch. Otherwise, you couldn't say your working tree represents that branch. Therefore, Git will need to remove any difference in content that is currently in your working tree but is not in the branch's tree. Thankfully, Git doesn't want you to loose uncommitted changes, so it will only let you checkout another branch if everything in your current working tree is committed.\\ \\This means that if you have uncommitted changes in your working directory and want to checkout another branch, you won't be able to do so until you commit or stash them away.")
{code}
JS-LOCAL             |        JS-FORK       |           OFFICIAL
                     |                      |
             master  |              master  |             master
               edge  |                edge  |               edge
                     |                      |
            topic-1' |          js/topic-1  |
            topic-2  |          js/topic-2  |
{code}

1.1.1.1 Backing up a local topic branch to the fork repo

* ~~Joe~~: Let's call this a day; time to go home!

{code}
2$ git commit -m "leaving home"
3$ git push
{code}
3- Syncs everything towards JS-FORK, thanks to ~~Joe~~'s usage of best practices when he set up his repository. Note that at the same time, the master and edge branches are automatically synced also. This behavior is automatic and implicit for the master branch; any other branch that's synced at the same time is done because we have previously set it up this way.\\
{code}
JS-LOCAL             |        JS-FORK       |           OFFICIAL
                     |                      |
             master --------------> master  |             master
               edge -------------->   edge  |               edge
                     |                      |
            topic-1'----------> js/topic-1' |
            topic-2 ----------> js/topic-2  |
{code}
JS-FORK's master and edge branches are now in sync ~~with the state of OFFICIAL at the time of the last sync from OFFICIAL to JS-LOCAL~~. This is what we want. It clearly highlights on which official revision of the edge branch ~~Joe~~'s ~~topic~~ branches are based. (There's probably more reasons for using this approach, too.)

1.1.1.1.1 Restoring a local topic branch from the fork repo

* ~~Jack~~: Yes! Now that ~~Joe~~ has left for home, it's time to make him pay for the last ~~public~~ humiliation he made me suffer!

{code}
$ #hack hack hack...
$ git branch -d topic-1    # -d means "delete"
{code}

* ~~Jack~~: HahahahahahahaHAAAAAAAA!

The sun goes down and up, and ~~Joe~~ comes back to work. For ~~some~~ reason, he wonders what happened to his ~~topic-1~~ branch. But anyway, he doesn't care too much:{code}
4$  git pull
{code}
4-  Syncs everything from JS-FORK, thanks to ~~Joe~~'s usage of best practices when he set up his repository.\\
{code}
JS-LOCAL             |        JS-FORK       |           OFFICIAL
                     |                      |
             master <-------------- master  |             master
               edge <--------------   edge  |               edge
                     |                      |
            topic-1'<---------- js/topic-1' |
            topic-2 <---------- js/topic-2  |
{code}





1.1.1 Asking a colleague for help

* ~~Joe~~: Ouch, I can't believe how this HTML programming language is hard to understand!

Luckily for ~~Joe~~, ~~Suzy Kue~~, a new employee, knows quite a deal about HTML.

* ~~Boss~~: ~~Joe~~, I thought you might need help with this new HTML thingy. If that ever happens, I think ~~Suzy Kue~~ might be the good candidate to ask for help. Our office in Japan just recruited her.

* ~~Joe~~: Oh thank you boss, but I should be fine, you know.

Joe then waits for the good moment to send an email to ~~super Suzy~~, when the boss won't be near his screen. And meanwhile, he pushes his latest changes to his public repo:

{code}
$ git commit
$ git push
{code}
{code}
JS-LOCAL             |        JS-FORK       |           OFFICIAL
                     |                      |
             master --------------> master  |             master
               edge -------------->   edge  |               edge
                     |                      |
            topic-1'----------> js/topic-1' |
            topic-2 ----------> js/topic-2  |
{code}

Sometime later, ~~the~~ moment comes for ~~Joe~~ to write an email to ~~Suzy~~, asking her to "take a look at this code if you don't mind: git://<...>/JS-FORK.git, *branch js/topic-1*".

Luckily  again for ~~Joe~~, 5 minutes later, he receives an answer from ~~Suzy~~, telling him to "have a look at my proposal for a fix, at: git://<...>SK-FORK.git, *branch js/topic-1*". ~~Joe~~ eagerly takes a look at Suzy's changes:

{code}
1$ git fetch js/topic-1 git://<...>SK-FORK.git topic-1-sk
2$ git diff  topic-1 topic-1-sk
3$ git merge topic-1-sk
{code}
1- ~~Joe~~ doesn't use "git pull" because he's not sure yet if he likes ~~Suzy~~'s patch; so he fetches it as ~~topic-1-sk~~.\\
2- A quick diff makes sense.\\
3- ~~Joe~~ likes ~~Suzy~~'s patch; therefore, he merges it into the current branch.\\
{code}
JS-LOCAL             |        JS-FORK       |           OFFICIAL
                     |                      |
             master  |              master  |             master
               edge  |                edge  |               edge
                     |                      |
               /------------ js/topic-1-sk  |
               |     |                      |
               V     |                      |
            topic-1' |          js/topic-1' |
            topic-2  |          js/topic-2  |
{code}

Now, what ~~Joe~~ doesn't know yet is that anyone may see that ~~Suzy~~ helped him with this patch.



1.1.1 Testing development changes with Hudson

~~Joe~~ is confident his changes should work fine.

* ~~Joe~~: ~~Boss~~ will be impressed seeing ~~my~~ mastery of HTML! Let's make sure, first, that our continuous integration tests won't fail.

{code}
$ git commit
$ git push js/topic-1 git://<ci-server>/<...>/project-dev.git
{code}

* ~~Joe~~: Cool, tests pass!




1.1.1 Requesting a pull from the official repo

Seeing ~~topic-1~~ is now feature-complete, ~~Joe~~ puts the finishing touches to the branch's code and prepares it to be integrated into OFFICIAL.

{code}
$ git commit
$ git push
{code}
{code}
JS-LOCAL             |        JS-FORK       |           OFFICIAL
                     |                      |
             master --------------> master  |             master
               edge -------------->   edge  |               edge
                     |                      |
            topic-1'----------> js/topic-1' |
            topic-2 ----------> js/topic-2  |
{code}

* ~~Joe~~: ~~Boss~~, ~~topic1~~ is done!
* ~~Boss~~: Great, Joe! Let's have a look at it! By the way, did you need ~~Suzy~~'s help, finally?
* ~~Joe~~: What for!?



1.1.1 Having a look at someone else's branch

~~Boss~~ pulls ~~topic1~~ on his BOSS-LOCAL from JS-FORK, and takes a look at it...

{code}
1$  git stash save my-actual-work
2$  git pull
3$  git remote add js git://<...>/JS-FORK.git
4$  git checkout -b edge-topic-1 edge
5$  git pull js js/topic-1
6$  git diff edge edge-topic-1
7$  git branch
8$  git checkout my-previous-branch
9$  git stash list
10$ git apply my-actual-work
{code}
1-  Puts away uncommitted changes temporarily
.
.
.
10- Restores some uncommitted changes that had been put away previously

* ~~Boss~~: Good work, ~~Joe~~!


1.1.1 Pulling a topic branch on the official repo



* ~~Boss~~: Let's edge ~~Joe~~'s ~~topic1~~ branch on OFFICIAL!

~~Boss~~ logs on OFFICIAL, pulls ~~topic1~~ from JS-FORK, and waits for Hudson:project:edge to tell him all tests have passed. 

...All tests pass. ~~Boss~~ commits ~~topic1~~ to edge.

{code}
JS-LOCAL             |        JS-FORK       |           OFFICIAL
                     |                      |
             master  |              master  |             master
               edge  |                edge  |              edge'
                     |                      |                ^
                     |                      |                |
            topic-1' |          js/topic-1'------------------/
            topic-2  |          js/topic-2  |
{code}

1.1.1 Rinsing and repeating

Meanwhile, ~~Joe~~ finishes his work on ~~topic2~~...

{code}
JS-LOCAL             |        JS-FORK       |           OFFICIAL
                     |                      |
             master <------------------------------------ master
                     |              master  |
                     |                      |
              edge' <------------------------------------  edge'
                     |                edge  |
                     |                      |
                     |          js/topic-1' |
           topic-2'  |          js/topic-2  |
{code}
{code}
JS-LOCAL             |        JS-FORK       |           OFFICIAL

                     |                      |
             master ------------->  master  |             master
              edge' ------------->   edge'  |              edge'
                     |                      |
                     |                      |
                     |                      |
                   --------->               |
           topic-2'--------->   js/topic-2' |
{code}

#info("If the remote branch doesn't get removed like I showed in this graph (I'm yet to test this), try [this>http://github.com/guides/remove-a-remote-branch] and please update this section according to the truth.")

Then ~~Boss~~ takes a look at ~~topic2~~; since it looks good to him and Hudson:project:edge is happy with it, ~~Boss~~ commits ~~topic2~~ on OFFICIAL's edge.

{code}
JS-LOCAL             |        JS-FORK       |           OFFICIAL
                     |                      |
             master  |              master  |             master
              edge'  |               edge'  |             edge''
                     |                      |               ^
                     |                      |               |
           topic-2'  |         js/topic-2'------------------/
{code}




1.1.1 Making a new release

 * ~~Boss~~: Congrats Team, OFFICIAL's edge is stable, let's call this a release!

~~Boss~~ tries a merge of edge with master on OFFICIAL, and waits for Hudson:project:*master* to tell him all tests pass.

~~Boss~~ commits and tags this new release.

{code}
JS-LOCAL             |        JS-FORK       |           OFFICIAL
                     |                      |
             master  |              master  |            master'
                     |                      |               ^
                     |                      |               |  
              edge'  |               edge'  |             edge''
                     |                      |
           topic-2'  |         js/topic-2'  |
{code}


1.1.1 Rinsing and repeating

Some time later, ~~Joe~~ starts work on ~~topic3~~...

{code}
JS-LOCAL             |        JS-FORK       |           OFFICIAL
                     |                      |
            master' <----------------------------------- master'
                     |              master  |
             edge'' <-----------------------------------  edge''
                     |               edge'  |
                     |                      |
                     |         js/topic-2'  |
            topic-3  |                      |
{code}



1.1.1 Grab the following help scripts!

1.1.1 Advantages of using this workflow

The advantages of this set of practices are many:
* Everyone works within their own repository
* Everyone works on their own schedule
* There’s no process waiting to be completed that blocks ~~me~~ from moving on to whatever ~~I~~ need/want to do next
* ~~I'm~~ not forcing anyone to drop what they’re doing right now to handle ~~my~~ pull requests
Moreover:
* Each repository is on an equal footing
* In particular, we would like every fork to have the same master branch, so that if the official repository should ever be lost, there would be plenty of redundant backups
* We also want it to be easy for each developer to pull in changes from the official repository
* Finally, it’s a bad idea in general to work on the master branch; experienced git users typically work on separate development branches and then merge those branches into master when they’re done
The extra work is worth the effort, because with this configuration:
* ~~My~~ changes will be easily identifiable in ~~My~~ named branch
* ~~I~~ can easily get updates from the official repository
* Any updates ~~I~~’ve pulled into master and edge are automatically pushed up to ~~my~~ fork on the server
* The simple ‘git push’ command will push up changes for all local branches that have a matching branch on the remote
* If ~~I~~ make it a point to pull in updates to my local master and edge but not work directly on them, my fork will match up with the official repository
So what is the benefit of all this to our team's projects?
* The easier it is for ~~me~~ to pull in updates, the more likely it will be that the pull request will be for code that merges easily with the latest releases
* ~~I~~ can tell if someone is pulling updates by looking at their master and edge branches and seeing if they match up with the latest branches on the official repository
* By getting ~~myself~~ in the habit of working on branches, the team is going to get better, more organized code contributions


1.1 References

* *General*
** [Git-SCM>http://www.git-scm.com] - Download, Community Book, Tutorials, Reference
** [GitHub Guides>http://github.com/guides/home]

* *Cheat Sheets*
** [Git Cheat Sheet>http://zrusin.blogspot.com/2007/09/git-cheat-sheet.html] - see this page's attachments for a cleanly resized version

* *Tutorials*
** [Official - Tutorial>http://www.kernel.org/pub/software/scm/git/docs/gittutorial.html]
** [Official - Git for SVN Users>http://git.or.cz/course/svn.html]
** [Official - Everyday Git with 20 commands>http://www.kernel.org/pub/software/scm/git/docs/everyday.html]
** [Git for The Lazy>http://www.spheredev.org/wiki/Git_for_the_lazy]
** [A Tour of Git - The Basics>http://cworth.org/hgbook-git/tour]
** [An introduction to git-svn for SVN deserters>http://utsl.gen.nz/talks/git-svn/intro.html]

* *Links*
** [Git Resources>https://37s.backpackit.com/pub/1465067]
** [Git-SCM's Documentation Links>http://www.git-scm.com]

* *Tutorials - More advanced stuff*
** [Git Awesomeness - Git Rebase --interactive>http://blog.madism.org/index.php/2007/09/09/138-git-awsome-ness-git-rebase-interactive]
** [The Thing About Git>http://tomayko.com/writings/the-thing-about-git]
** [Official - Git How To>http://www.kernel.org/pub/software/scm/git/docs/howto-index.html] - Advanced stuff

* *Reference*
** [Official - Man Pages>http://www.kernel.org/pub/software/scm/git/docs/]
** [Official - FAQ>http://git.or.cz/gitwiki/GitFaq]
** [Git for The Confused>http://www.gelato.unsw.edu.au/archives/git/0512/13748.html]
** [Git-SCM's Documentation Links>http://www.git-scm.com]

* *Screencasts* - A great, quick way to understand Git
** [Git Casts>http://gitcasts.com/]
** Community Book (through Git-SCM site link upwards) - in HTML version only
** [Peepcode's Git Screencast>http://peepcode.com/products/git] (Costs 9$)

* *Deep Understanding / Books*
** [Git for Computer Scientists>http://eagain.net/articles/git-for-computer-scientists/] - small
** [Git From Bottom Up>http://www.newartisans.com/blog_assets/git.from.bottom.up.pdf] (PDF) - Useful, deep understanding coverage
** Git From Bottom Up (PDF with my yellow highlightings) - see this page's attachments to download it
** [Git Magic>http://www-cs-students.stanford.edu/~blynn/gitmagic/]
** [Git-SCM's Community Book>http://www.git-scm.com] - Always up-to-date; Wide coverage
** [Peepcode's Git Internals Book>http://peepcode.com/products/git-internals-pdf] (Costs 9$) - Complementary; Wide coverage

* *Workflow*
** [Our Git Deployment Workflow>http://www.brynary.com/2008/8/3/our-git-deployment-workflow]

* *Serving* - Don't forget: touch proj.git/git-daemon-export-ok
** Bare HTML read-only
** [Git daemon>http://www.kernel.org/pub/software/scm/git/docs/git-daemon.html] (bare/manual, httpd, inetd)
** [Gitosis>http://www.urbanpuddle.com/articles/2008/07/11/installing-git-on-a-server-ubuntu-or-debian]

* *Hosting*
** [GitHub>http://www.github.com] - Commercial Web Front; Free only for Public-Small; Highly social site; Very useful; Pleasing to use
** [Gitorious>http://www.gitorious.org] - Open Source Web Front; Free hosting
** [Repo.or.cz>http://repo.or.cz] - Git Web Front - Free hosting

* *Java*
** JGit - The most complete implementation of Git in other languages.
** [Maven-enabled project hosting with GitHub>http://www.jroller.com/mrdon/entry/maven_enabled_project_hosting_with]

* *Best Practices*
** [Setting up your repos for shared projects>http://blog.insoshi.com/2008/10/14/setting-up-your-git-repositories-for-open-source-projects-at-github/]
 




1 See attachments below





















